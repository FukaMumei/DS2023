一、 非C++内建型别A和B, 在哪几种情况下B能隐式转化为A有四种方法：

第一种：classB: public A {…}

B公有继承A，可以是间接公有继承，当把B的对象赋值给A，会发生隐式转换。

（待求证，保护继承、私有继承、B是A的成员能否发生转换？）

第二种：classB:

{

OperatorA();

….

}

转换constructor。类B实现了隐式转化为类A；compiler会在需要的时候自动调用该函数发生类型转换，如果想要在代码中显式的调用转换函数才能发生类型转化，可以定义explicitoperator A()

第三种：class A

{

A （const B &）

}

A实现了一个个non-explicit的构造函数，参数为B（还可以带其他的有缺省值的参数）

第四种：A&operator ＝（const B & ）

赋值操作，不是正宗的隐式类型转换，但可以勉强算一个。

注意：对于类之间的公有继承总可以把子类转化为父类，只是把派生类对象切割为基类对象即可。

注意2：上述第二种和第三种方法同时存在一个程序中，应该注意这样的调用：

f（const A &）；

B b;

f(b)则会产生调用的二义性。

注意3：如果不想使用隐式生成的函数（当然这些函数一般是缺省构造函数、copy构造函数和赋值构造函数），就要把它显式的禁止；对于一般的转换constructor可以添加explicit明确的要求显式的调用，compiler不能自动发生隐式转换。如：

Private：

A &operator = (const B &）;

A (const A & );


